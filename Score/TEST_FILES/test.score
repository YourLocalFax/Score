
/# This is the first data type I want to support
data Answer = yes | no

/# This is the first *generic* data type I want to support
/# This is actually usefull, so.
data Maybe t = none | some t



/# a result type
data Res t e = ok t | err e

/# a function that should be found
/# somewhere else.
extern fn puts |^i8| -> i32

/# the main entry point. this one prints the args.
fn main |args: [str]| -> () {
	/# each loop, iterates over things
	/# each can still be used as an identifier,
	/# like other keywords, as a literal.
	/#   list .'each function
	/# will call the 'each' method on the list
	/# passing the given function.
	each arg : args {
		println arg
	}
	/# That's basically the same as this (hopefully, eventually)
	arg .'each println
}

struct vec2 |x: float = 0, y: float = x| {
	fn + |that: vec2| -> vec2 {
		vec2 (x + that.x) (y + that.y)
	}
}

fn parse_i32 |in: str| -> Res i32 str {
	let result: i32 /# this is undefined, and is not allowed to be used until assigned to
	/# do parsing stuff, probably assign to 'result'
	if /* we failed somwhere, there'll be a few of these */ {
		err v"some kind of failure"
	}
	ok result
}

/# a function that repeats a str count times.
/# this can be called as such:
/#   rep "hello" 10
/# or
/#   "hello" `rep 10
fn rep |val: str, count: u32| -> str {
	let res: str mut = val
	for i: u32 = 1; i < count; i++ {
		res:: = val
	}
	res
}

fn get_tokens -> Res (vec token) str {
	let res: vec token mut = _
	let state: LexerState = _

	loop {
		/# state .get_token -> Res (Maybe token) bool
		match state .get_token {
			ok (some tok): res << tok
			err true: err "failed to lex"
			_: break
		}
	}

	ok res
}

fn main |args: [str]| -> () {
	/# functions can contain data in the main scope
	/# as if they were namespaces
	struct 'data {
		args: [str,]
		flags: u32
	}
	let d = 'data args 0b0110u8
	handle_things d
}

fn handle_things |d: main .'data| -> () {
	/# do things
}

/# Not-else blocks? (cont maybe?) Executed if the else WASN'T executed.

/# this stuff would be defined somewhere
struct entity {
	pos mut: (f32,),
}

type cmd = || (entity) -> ()
type action = (cmd,)

impl action {
	fn do || (plr) { this .0 : plr () }
	fn undo || (plr) { this .1 : plr () }
}

fn make_move_to |pos: (f32,)| -> (cmd,) = {
	let last mut = pos
	(|| (e) {
		last = e .pos
		e .pos = pos
	}, || (e) { e.pos = last })
}

/# and these would be used for actual things
let plr = entity (10f, 5f)
let to_orig = make_move_to (0f, 0f)

/# The player starts at (10,5)
to_orig.do : plr ()
/# Here, the player is now at (0,0)
to_orig.undo : plr ()
/# And here, the player is back at (10,5)


type observer = || (entity) -> ()

event on_fall: observer
/# or
let on_fall: event observer

let handle = on_fall :: || (e: entity) {
	/# logic for when an entity falls.
}

handle!!







/# Define the 'number' data type
data number = Int(i32) | Float(f32)

/# Declare a method that each type should implement.
impl number {
	fn + |that: number| -> number
}

/# Implement that method on Int
impl number.Int(value) {
	fn + |that: number| -> number {
		match that {
			Int(right): Int(value + right),
			Float(right): Float(value + right),
		}
	}
}

/# Implement that method on Float
impl number.Float(value) {
	fn + |that: number| -> number {
		match that {
			Int(right): Float(value + right),
			Float(right): Float(value + right),
		}
	}
}



data laye_obj = Int(i32) | Float(f32) | String(str)

impl laye_obj {
	fn + |that: laye_obj| -> laye_obj {
		match this {
			Int(value): match that {
				Int(value2): Int(value + value2)
				/#
			}
			Float(value): /#
			String(value): /#
		}
	}
}

impl laye_obj.Int(value) {
	fn + |that: laye_obj| -> laye_obj {
		match that {
			Int(value2): Int(value + value2)
			/#
		}
	}
}







/# CURRENTLY *VERY* RUST LIKE, JUST MESSING WITH IDEAS


/# core_os.sr


/#[conf = os "android" | (os "linux" & (arch "aarch64" | arch "arm"))]
/#[stable (feature "core_os", since "1.0.0")]
pub type c_char = u8

/#[conf = !(os "android" | (os "linux" & (arch "aarch64" | arch "arm")))]
/#[stable (feature "core_os", since "1.0.0")]
pub type c_char = i8

/#[stable (feature "core_os", since "1.0.0")]
pub type c_schar = i8

/#[stable (feature "core_os", since "1.0.0")]
pub type c_uchar = u8

/#[stable (feature "core_os", since "1.0.0")]
pub type c_short = i16

/#[stable (feature "core_os", since "1.0.0")]
pub type c_ushort = u16

/#[stable (feature "core_os", since "1.0.0")]
pub type c_int = i32

/#[stable (feature "core_os", since "1.0.0")]
pub type c_uint = u32

/#[conf = pointer_width "32" | windows]
/#[stable (feature "core_os", since "1.0.0")]
pub type c_long = i32

/#[conf = pointer_width "32" | windows]
/#[stable (feature "core_os", since "1.0.0")]
pub type c_ulong = u32

/#[conf = pointer_width "64" & !windows]
/#[stable (feature "core_os", since "1.0.0")]
pub type c_long = i64

/#[conf = pointer_width "64" & !windows]
/#[stable (feature "core_os", since "1.0.0")]
pub type c_ulong = u64

/#[stable (feature "core_os", since "1.0.0")]
pub type c_longlong = i64

/#[stable (feature "core_os", since "1.0.0")]
pub type c_ulonglong = u64

/#[stable (feature "core_os", since "1.0.0")]
pub type c_float = f32

/#[stable (feature "core_os", since "1.0.0")]
pub type c_double = f64

/#[stable (feature "core_os", since "1.0.0")]
pub data c_void: u8 = priv __var1 | priv __var2



















fn add |a: i32, b: i32| -> i32 = a + b


fn add |a, b| = a + b
/# is this:
trait addable<B, R> {
	fn + |that: B| -> R
}
fn add<B, R> |a: addable, b: B| -> R = a + b

